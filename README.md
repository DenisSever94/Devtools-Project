# My devtools project
[![Java CI with Checkstyle and JaCoCo](https://github.com/DenisSever94/Devtools-Project/actions/workflows/ci.yml/badge.svg)](https://github.com/DenisSever94/Devtools-Project/actions/workflows/ci.yml)
# Practice Project

## Технологический стек проекта

### Языки и платформы
- **Java 25 LTS** — основной язык разработки
- **Gradle 9.0.0** — система сборки (через Gradle Wrapper)

### Инструменты качества кода
- **Checkstyle** — статический анализ стиля кода
    - Конфигурация: `config/checkstyle/checkstyle.xml`
    - Запуск: `./gradlew checkstyleMain`
- **JUnit 5** — фреймворк тестирования
    - Запуск: `./gradlew test`

### CI/CD
- **GitHub Actions** — автоматическая проверка PR
    - Checkstyle на каждый коммит
    - Тесты на каждый коммит
    - Конфигурация: `.github/workflows/`

### Правила кода
- Стиль: Google Java Style Guide (через Checkstyle)
- Коммиты: Conventional Commits (`feat:`, `fix:`, `docs:`)
- Ветки: `feature/DVT-X` для задач, `master` — основная
- Pull Request: обязателен для слияния в master

# Quick start:

### Через Gradle Tool Window:
Откройте в правой части IDEA вкладку Gradle 
(или Tool View -> Tool Windows -> Gradle)
Разверните дерево проекта devtools -> Task 
Дважды щелкните по нужной задаче:
- **build** -> полная сборка проекта (компиляция, тесты, создание JAR)
- **test** -> запуск всех модульных тестов
- **run** -> запуск основного класса application

### Через Run Anything
- **Нажмите** -> Ctrl + Ctrl дважды в любой части IDE
- **В появившемся окне** введите имя задачи (build, test, run) и нажмите Enter
- **IDEA** выполнит задачу автоматически отрыв окно выполнения
- **Для задачи run** можно использовать зеленую стрелочку рядом ▶️ с объявлением сновного класса и методом main

### Packages
- **Структура пакетов организована по доменному принципу для обеспечения четкой логической организации кода:**
- **ru.mentee.power** корневой пакет проекта

### Table variables
- **String menteeName** Имя ученика работающим над задачами
- **int sprintNumber** Номер текущего спринта 
- **int plannedHoursPerWeek** Количество часов запланированных на рабочую неделю

### Правило readyForSprint()
- **Ученик готов** если количество часов >= 3

### Правило веток
- **master** основная ветка. В нее сливаются только проверенные изменения
- **feature/DVT-X** ветка для разработки новой функциональности, где 'X' это номер задачи

- **Examples:**
- 'master'- стабильная ветка по умолчанию
- 'feature/DVT-3'- ветка для разработки задачи DVT-3

## Сценарий ручной проверки DVT-6

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До: 
import java.util.List; 
import java.util.ArrayList; 
import java.io.File;

После:
import java.io.File;
import java.util.ArrayList;
import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.


## Результаты само-ревью DVT-9

### Найдено и исправлено проблем: 3

#### 1. Проблема в классе StudentList нет метода для поиска студента по имени
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** есть метод для поиска студента по городу, но нет по имени

**Почему важно** Пользователь может найти студента по имени 

**Как исправить** предлагаю реализовать метод для поиска по имению findStudentByName


#### 2. Нейминг studentList
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** название переменной в строке 8 "studentList" может быть избыточным так как и класс называется StudentList

**Как исправить** предлагаю переименовать в "students", так будет понятней, что это список студентов и никак не будут
пересекаться с названием класса.


#### 3. Нейминг метода getStudent 
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** название метода в целом рабочее, но для читабельности и более точного понимания, что делает метод,
а метод именно ищет студента в списке students, предлагаю переименовать на findStudentByCity.

#### Формат сообщения сдачи в Telegram 

- DVT-9: Правила Code Review
- Репозиторий: ССЫЛКА
- Pull Request: ССЫЛКА
- Статус: готова
- 
  @dev_tools


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос               | Операторы                                                    | Официальный источник                                                                                                                                        | Альтернатива                                                       | Статус | Дата проверки |
|---|----------------------|--------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|--------|---------------|
| 1 | Lombok Gradle Short  | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://central.sonatype.com/artifact/org.projectlombok/lombok/1.18.42/overview                                                                             | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.42 | 200 OK | 10.01.2026    |
| 2 | Stream Api           | site:docs.oracle.com "stream api" intitle:api java 25        | https://docs.oracle.com/en/middleware/standalone/coherence/15.1.1/develop-applications/using-repository-api.html#GUID-6FE2A09E-71FF-4D65-AB04-972B95BA87D6  | https://www.jetbrains.com/help/inspectopedia/Convert2streamapi.html | 200 OK | 10.01.2026    |
| 3 | keymap intellij idea | site:jetbrains.com/help "keymap intellij idea"               |https://www.jetbrains.com/help/idea/settings-keymap.html  | https://woori.studio/wp-content/uploads/2017/01/intellijidea_referencecard_mac.pdf | 200 OK | 10.01.2026    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения
**Роль** ты java senior developer с 10 годами опыта.
**Задача:** Мне нужно добавить метод для сортировки по имени в алфавитном порядке в класс Student с полем name.
**Контекст:** Java 25, проект на gradlew, SOLID.
**Ограничения:** не использовать stream api, учти что может быть несколько одинаковых имен.
**Ожидаемый результат:** план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам
**Критерии успеха:** План конкретный и последовательный, каждый шаг — четкое действие.

**AI-1 ([DeepSeek]):**

План реализации метода сортировки студентов по имени:

Добавить метод сравнения в класс Student:

Реализовать интерфейс Comparable<Student> с методом compareTo().

Почему: Это стандартный Java-подход для естественного порядка сортировки объектов. Позволит использовать Collections.sort() без передачи компаратора каждый раз. Учитываем, что имена могут повторяться, поэтому порядок одинаковых имен не важен — можно возвращать 0.

Переопределить equals() и hashCode() для согласованности:

Обновить методы, чтобы они учитывали только поле name или все поля (в зависимости от бизнес-логики).

Почему: При реализации Comparable рекомендуется соблюдать контракт: compareTo() должен быть согласован с equals(). Это предотвратит противоречивое поведение в коллекциях.

Добавить статический компаратор в Student:

Создать public static final Comparator<Student> NAME_COMPARATOR с лямбдой или анонимным классом.

Почему: Предоставит гибкость для сортировки только по имени без учета других полей. Соответствует SOLID (принцип единственной ответственности — класс отвечает и за свои данные, и за логику их сравнения).

Протестировать сортировку в отдельном классе:

Создать список студентов с дубликатами имен и разными данными.

Проверить сортировку через Collections.sort(list) и Collections.sort(list, Student.NAME_COMPARATOR).

Почему: Убедимся, что сортировка работает корректно с повторяющимися именами, не ломает существующий код и соответствует контрактам.

Обновить документацию:

Добавить JavaDoc к методу compareTo() и компаратору, указав, что сортировка идет по алфавиту и одинаковые имена считаются равными.

Почему: Это улучшит читаемость кода и поможет другим разработчикам правильно использовать функциональность без изучения реализации.

Ключевые моменты для реализации:

Использовать String.compareTo() для сравнения имен.

При дубликатах имен возвращать 0 (или сравнивать по дополнительному полю, например ID, если требуется уникальность — но по ТЗ это не нужно).

Учесть регистр букв: String.compareTo() чувствителен к регистру. Если нужна регистронезависимая сортировка, используйте String.compareToIgnoreCase().

Gradle сборка не требует изменений, так как меняется только исходный код.



**AI-2 ([ChatGPT]):**

Добавить локаль- и null-безопасный Comparator в класс Student (или сделать public static константу Comparator).

Правила сравнения: null-элементы списка и/или null-имена обрабатываются предсказуемо (например, null имя считается «больше» ненулевого — чтобы такие записи шли в конец).

Использовать Collator (или эквивалент) для корректной алфавитной сортировки с учётом локали и регистра; настроить силу сравнения так, чтобы, при необходимости, регистр не влиял.

Добавить в Student вспомогательный метод-сортировщик, который сортирует список на месте (in-place) с использованием этого Comparator, без Stream API.

Метод должен принимать List<Student> и валидировать аргументы (null-check).

Использовать стандартный алгоритм сортировки коллекций (например Collections.sort / List.sort) — он стабильный, то есть сохраняет относительный порядок одинаковых имён (важно для дубликатов).

Документировать: «сортирует на месте; для неизменяемого поведения используйте overload, возвращающий копию списка».

Написать альтернативу для неизменяемости/чистоты (опционально, но на проде полезно): метод, возвращающий новый отсортированный List<Student> (не мутирует вход).

Внутри создаёт shallow-copy списка, сортирует его тем же Comparator-ом и возвращает копию.

Это даёт гибкость и соответствует принципам единой ответственности у вызывающих компонентов.

Покрыть поведение тестами и документировать контракт.

Юнит-тесты: случаи с одинаковыми именами (проверка стабильности), с null-именами, с разными локалями/регистрами, и проверка, что метод сортирует на месте / возвращает копию (в зависимости от варианта).

В javadoc укажи: «не использует Stream API», «поведение с null», «локаль сравнения», «сложность O(n log n)» и что метод стабильный.

Почему именно так (коротко и по делу)

Comparator + Collator даёт корректную, локалезированную и предсказуемую алфавитную сортировку (в отличие от простого String.compareTo, который игнорирует локаль и может вести себя странно с диакритикой).

Статический Comparator в модели — удобная точка согласия: другие слои (репозиторий, сервис) могут переиспользовать правило сортировки, не создавая дублирования. Если ты строго следуешь SOLID, можно вынести Comparator в StudentComparators / StudentUtils (Single Responsibility) — поэтому я предложил и вариант вынести.

Сортировка на месте (Collections.sort / List.sort) — простая и эффективная (TimSort, стабильная), и удовлетворяет требованию «не использовать stream api». При этом обязательно документировать / предоставить вариант, возвращающий копию, чтобы не ломать ожидаемое поведение вызывающих компонентов.

Явная обработка null и тесты убирают класс ошибок, которые в проде любят подкидывать продакшен-данные.

Юнит-тесты и javadoc — обязательны для ясного контракта и безопасного рефакторинга в будущем.

**Сравнение:** 

В целом оба ассистента дали одинаковые ответы, но описали по-разному немного.
Предложили одинаковые варианты решения, но ChatGpt еще напомнил про тесты.
Не могу выбрать один из них, так как оба дали похожие решения,
но можно использовать их вместе, для того, чтоб получить максимально расширенный ответ.

Добавил "Роль" так как читал про составление промта и рекомендуется задавать роль AI.


#### Промпт 2: Проверка кода

**Код для проверки:**

**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 ([DeepSeek]):**

1. Логические ошибки
   Критические:

totalRemaining вычисляется неправильно - расчет внутри цикла приводит к некорретному промежуточному значению, так как totalTotal и totalCompleted еще не полностью посчитаны. Нужно вычислять после цикла.

Возможные:

При нулевом массиве выбрасывается исключение, но в требовании метода это не указано. Нужно уточнить требования.

2. Соответствие Code Conventions
   Нарушения:

Имя параметра: mentees - должно быть в единственном числе для массива (mentees → menteeArray или просто mentees если это коллекция)

Имя переменной: totalTotal - нечитаемое имя. Лучше totalLessons или overallLessons

Именование метода: completedLessons() и totalLessons() - нарушение camelCase для геттеров, должно быть getCompletedLessons() и getTotalLessons()

Пробелы в строке результата: В выводе есть пробелы, но их может быть недостаточно для читаемости

Комментарий на русском: Хотя это допустимо в корпоративном коде, обычно пишут на английском

Пустые строки: Не хватает пустых строк для разделения логических блоков

3. Производительность
   Проблемы:

Лишняя переменная index: Можно использовать enhanced for-loop

Лишняя переменная totalRemaining: Можно вычислять непосредственно в return

Многократный вызов геттеров: В текущей реализации каждый геттер вызывается один раз - это нормально

**AI-2 ([ChatGPT]):**

Логические ошибки

Счёт totalRemaining внутри цикла
Сейчас ты каждый раз внутри while пересчитываешь totalRemaining = totalTotal - totalCompleted;. Это корректно, но лишнее: достаточно вычислить один раз после суммирования всех mentee. Так меньше лишних операций и яснее код.

Валидность входного массива
Проверка mentees == null || mentees.length == 0 корректна — исключение выбрасывается.

Накопление totalCompleted и totalTotal
Всё верно, суммирование через += безопасно.

Потенциальный нюанс: если completedLessons() > totalLessons(), может получиться отрицательное totalRemaining. Возможно, стоит добавить защиту или хотя бы документировать, что метод ожидает корректные значения.

Формат возвращаемой строки

В текущей реализации между "из X" и "Осталось" нет запятой или точки с запятой, что может выглядеть слегка слипшимся. Чисто косметически лучше: "Суммарно пройдено: 5 из 10. Осталось: 5".

2️⃣ Соответствие Code Conventions (Java)

Название класса и методов — правильное, ProgressTracker и calculateTotalProgress. ✅

Javadoc — есть, но:

@param mentees array mentee → лучше: @param mentees массив menteе или массив учеников.

@return → лучше: @return строка с суммарным прогрессом группы.

Отступы и форматирование — верно.

Именование переменных — ясное, но можно убрать index и использовать for-each (чистый стиль, читаемость выше):

for (Mentee mentee : mentees) {
totalCompleted += mentee.completedLessons();
totalTotal += mentee.totalLessons();
}


Именование totalRemaining — по стилю ок, но можно объявить ближе к месту использования (после цикла).

Производительность

Сложность O(n) — идеально, перебираем массив один раз.

Лишние вычисления

totalRemaining = totalTotal - totalCompleted внутри цикла → лишняя операция n раз. Можно вынести за цикл.

Использование while vs for-each

for-each чуть эффективнее для читаемости и предотвращает ошибки с индексами, но на уровне JVM различия почти нулевые.

Строка конкатенации через +

Для коротких строк в небольших методах — норм, JVM оптимизирует через StringBuilder. Если планируется вызывать метод для сотен тысяч записей, тогда лучше явно через StringBuilder.
 
Вывод / рекомендации

Перенести вычисление totalRemaining после цикла.

Рассмотреть for-each вместо while — читаемее.

Мелкие правки Javadoc и форматирование возвращаемой строки.

Логика корректна, производительность для массивов обычного размера — достаточная.

**Сравнение:**

В целом оба ассистента дали одинаковые ответы, но описали по-разному немного.
Предложили одинаковые варианты решения, но ChatGpt еще напомнил про тесты.
Не могу выбрать один из них, так как оба дали похожие решения,
но можно использовать их вместе, для того, чтоб получить максимально расширенный ответ.

Итоговый вывод:
Лучше использовать обе модели и находить то, что одна из них могла упустить или не подсветить.


## Личный глоссарий терминов Dev Tools

### Структура глоссария

Каждый термин содержит:
- **RU / EN** — русское и английское название
- **Определение** — краткое (1-2 предложения) объяснение термина
- **Контекст использования** — где и когда применяется
- **Пример** — конкретное применение в коде/команде/документации
- **Источник** — ссылка на официальную документацию

---

### Категория: Java-экосистема

#### JDK — Java Development Kit

**Определение:** Development environment for building applications using the Java programming language. Includes compiler (javac), archiver (jar), documentation generator (javadoc), and other tools.

**Контекст использования:** JDK необходим для компиляции Java-кода в байт-код и создания исполняемых JAR-файлов. Без JDK невозможно собрать Java-проект.

**Пример:** После установки JDK выполняем `java -version` для проверки версии. В IntelliJ IDEA настраиваем Project SDK: File → Project Structure → Project → SDK → выбираем JDK 25.

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/

---

#### JRE — Java Runtime Environment

**Определение:** The JRE is the software environment in which programs compiled for a typical JVM implementation can run. The runtime system includes: The code necessary to run Java programs, dynamically link native methods, manage memory, and handle exceptions.

**Контекст использования:** JRE необходим для запуска уже скомпилированных Java-программ. Он содержит виртуальную машину (JVM) и стандартные библиотеки, но не включает инструменты для разработки (компилятор, отладчик), для которых нужен JDK.

**Пример:** Чтобы запустить скомпилированный Java-архив (JAR), используйте команду: java -jar имя_приложения.jar.

**Источник:** https://docs.oracle.com/cd/E19620-01/805-4031/6j3qv1oec/index.html

---

#### JVM - Java Virtual Machine

**Определение:** The JVM is an abstract computing machine, having an instruction set and using memory. Virtual machines are often used to implement a programming language. The JVM is the cornerstone of the Java programming language. It is responsible for Java's cross-platform portability and the small size of its compiled code.

**Контекст использования:**JVM — это исполняющая среда, которая обеспечивает кроссплатформенность Java ("написал один раз — запускай везде"). Она загружает, проверяет и выполняет байт-код, преобразуя его в машинные инструкции для конкретной операционной системы.

**Пример:** Команда java Main запускает JVM. JVM загружает байт-код из файла Main.class, выполняет его и управляет памятью во время работы программы

**Источник:** https://docs.oracle.com/cd/E19620-01/805-4031/6j3qv1oea/index.html

---

### Категория: Инструменты разработки

#### Git — Git

**Определение:** Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

**Контекст использования:** Git используется для контроля версий кода как в одиночных, так и в командных проектах. Он позволяет фиксировать изменения, создавать параллельные линии разработки (ветки), а также синхронизировать код между локальным компьютером и удалёнными репозиториями (например, на GitHub).

**Пример:** Для начала работы с существующим проектом его нужно склонировать: git clone https://github.com/username/repository.git.

**Источник:** https://git-scm.com/

---

#### Git - Commit

**Определение:** Commit — это операция фиксации изменений, которая создаёт постоянный снимок состояния файлов в репозитории на определённый момент времени. Каждый коммит имеет уникальный идентификатор (хеш), автора, сообщение и ссылку на предыдущий коммит.

**Контекст использования:** Коммиты используются для сохранения истории изменений проекта. Они позволяют вернуться к любой предыдущей рабочей версии, понять, кто и что изменил, и безопасно экспериментировать с кодом.

**Пример:** После внесения изменений в файлы их нужно добавить в индекс и зафиксировать: 
- `git add .`
- `git commit -m "feat: добавить новую функцию проверки ввода"`

**Источник:** https://git-scm.com/docs/git-commit

---

#### Git - Push

**Определение:** Push — это операция отправки локальных коммитов из текущей ветки в удалённый репозиторий (например, на GitHub или GitLab), обновляя там историю изменений.

**Контекст использования:** Push используется для публикации своих изменений, чтобы они стали доступны другим участникам команды, или для создания Pull Request. Без push изменения остаются только на локальном компьютере.

**Пример:** После создания коммита в ветке feature/login отправляем изменения на сервер:
- `git push -u origin feature/***`
- **Флаг** `-u` связывает локальную ветку с удалённой для последующих упрощённых команд git push.

**Источник:** https://git-scm.com/docs/git-push

---

#### Git - Pull

**Определение:** Pull — это операция получения изменений из удалённого репозитория и их автоматического слияния с текущей локальной веткой. Команда объединяет в себе git fetch (загрузка изменений) и git merge (их интеграцию).

**Контекст использования:** Pull используется для синхронизации локальной копии репозитория с актуальным состоянием на сервере. Это обязательная практика перед началом новой работы, чтобы избежать конфликтов и работать с последней версией кода.

**Пример:** Чтобы обновить локальную ветку master изменениями из удалённого репозитория:
- git checkout master
- git pull origin master

**Источник:** https://git-scm.com/docs/git-pull

---

#### Git - Branch

**Определение:** Branch (ветка) — это подвижный указатель на один из коммитов, представляющий собой независимую линию разработки. Ветки позволяют вести работу над разными задачами (фичами, исправлениями) изолированно, не затрагивая основную стабильную версию кода (например, master или main).

**Контекст использования:** Ветки создают для разработки новых функций (feature/), исправления багов (fix/), экспериментов или подготовки релизов. Они являются фундаментом для workflow с Pull Request.

**Пример:** Создание новой ветки для задачи и переход на неё:
- `git checkout -b feature/***`

**Источник:** https://git-scm.com/docs/git-branch

---

####  Pull Request — Pull Request (или Запрос на слияние)

**Определение:** Pull requests — это предложения по объединению изменений кода в проект. Pull request — это базовая функция сотрудничества GitHub, позволяющая обсуждать и анализировать изменения перед их объединением. Это помогает командам работать вместе, своевременно выявлять проблемы и поддерживать качество кода.

**Контекст использования:** Pull requests используются в процессе разработки для проведения Code Review перед слиянием (merge) изменений из feature-ветки в основную ветку (например, master или main). Они позволяют команде обсудить код, запустить автоматические проверки (CI) и выявить логические ошибки до их попадания в стабильную версию проекта.

**Пример:** В проекте devtools после завершения работы над заданием в ветке `feature/***` я создаю Pull Request для её слияния с `master`. В интерфейсе GitHub я выбираю `base: master, compare: feature/***`

**Источник:** https://docs.github.com/ru/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests

---

#### Gradlew - Dependency (Зависимость) 

**Определение:** Внешняя библиотека, фреймворк или модуль, который требуется проекту для компиляции, тестирования или выполнения. В Gradle зависимости объявляются в файле build.gradle и автоматически загружаются из репозиториев (например, Maven Central).

**Контекст использования:** Зависимости позволяют использовать готовый код из внешних библиотек, не реализуя всё с нуля. Без объявления зависимости компилятор выдаст ошибку, если код ссылается на классы из этой библиотеки. Они объявляются в скриптах сборки (например, build.gradle) в разделе dependencies.

**Пример:** Для написания unit-тестов в проекте в файл build.gradle добавлена зависимость от фреймворка JUnit Jupiter:
- testImplementation 'org.junit.jupiter:junit-jupiter:5.9.3'

**Источник:** https://docs.gradle.org/current/userguide/dependency_management_basics.html

---

#### Gradle Wrapper - Gradle Wrapper

**Определение:** Набор скриптов (gradlew, gradlew.bat, gradle-wrapper.properties) и файлов конфигурации, который обеспечивает выполнение сборки проекта с использованием заранее заданной и единой для всех версии Gradle. Wrapper автоматически скачивает и использует нужную версию Gradle, если она отсутствует в системе.

**Контекст использования:** Gradle Wrapper решает проблему обеспечения единой версии Gradle для всех разработчиков и сред (IDE, CI-серверы), автоматизируя загрузку и запуск нужной версии. Это устраняет проблемы несовместимости ("у меня работает, а у других — нет") и упрощает настройку проекта на новых машинах, где сам Gradle не установлен глобально.

**Пример:** В проекте для выполнения сборки и всех проверок (включая тесты и Checkstyle) используется команда:
- `./gradlew check`
- Запуск этого скрипта гарантирует, что сборка пройдёт с версией Gradle, указанной в gradle/wrapper/gradle-wrapper.properties.

**Источник:** https://docs.gradle.org/current/userguide/gradle_wrapper_basics.html

---

####  CI/CD — CI/CD (Continuous Integration / Continuous Delivery/Deployment)

**Определение:** Непрерывная интеграция (CI) — это практика автоматической сборки и тестирования каждого изменения кода в общем репозитории. Непрерывная доставка/развёртывание (CD) — это практика автоматического развёртывания проверенного кода в тестовую или продуктовую среду. Вместе они образуют процесс автоматизации этапов поставки программного обеспечения.

**Контекст использования:** Практика CI/CD позволяет командам раньше выявлять ошибки, повышать качество кода и ускорять выпуск стабильных обновлений. CI автоматизирует проверки (сборка, тесты, статический анализ), а CD автоматизирует развёртывание. Это сокращает количество ручных операций, снижает риски и позволяет разработчикам сосредоточиться на написании кода.

**Пример:** В репозитории devtools настроен workflow GitHub Actions (файл .github/workflows/ci.yml), который автоматически запускает `./gradlew check` (сборку, тесты и Checkstyle) при каждом push в ветку или создании Pull Request. Это реализация этапа Continuous Integration.

**Источник:** https://docs.github.com/en/actions/get-started/continuous-integration

---

#### Checkstyle — Checkstyle

**Определение:** Checkstyle — это инструмент разработки, помогающий программистам писать Java-код, соответствующий стандартам кодирования. Он автоматизирует процесс проверки Java-кода, избавляя людей от этой скучной (но важной) задачи. Это делает его идеальным для проектов, стремящихся к соблюдению стандартов кодирования.

**Контекст использования:** Checkstyle используется для поддержания единого и читаемого стиля кода в команде, что упрощает совместную работу и ревью. Он автоматически обнаруживает нарушения заданных правил (отступы, имена переменных, импорты и т.д.) и интегрируется в процесс сборки (Gradle/Maven), а также в конвейер CI/CD (например, GitHub Actions), что гарантирует проверку каждого изменения.

**Пример:** В проекте devtools для проверки кода на соответствие стандартам используется команда `./gradlew checkstyleMain`. Набор правил, таких как соблюдение Google Java Style Guide, задаётся в файле конфигурации config/checkstyle/checkstyle.xml. Эта проверка автоматически запускается при каждом коммите через GitHub Actions.

**Источник:** https://checkstyle.org/

---

#### Репозиторий — Repository

**Определение:**

- **В контексте Git:** Репозиторий — это хранилище, содержащее все файлы проекта и полную историю их изменений, управляемую системой контроля версий Git. Это базовая единица, с которой работает Git.


- **В контексте систем сборки (Maven/Gradle):** Репозиторий — это каталог (локальный или удалённый сервер), в котором хранятся скомпилированные артефакты (библиотеки), доступные для загрузки в качестве зависимостей проекта.

**Контекст использования:**
- это основа для хранения кода, отслеживания его истории и совместной работы. Без него невозможна работа с Git.

- Maven-репозиторий (как Maven Central) — это источник библиотек, без которого невозможно подключить внешние зависимости в build.gradle.
- 
**Пример** 
- 
- **Git** Проект devtools размещён в удалённом Git-репозитории на GitHub по адресу https://github.com/DenisSever94/Devtools-Project. Локальная копия была создана командой git clone.

- **Maven/Gradle:** В файле build.gradle проекта объявлен репозиторий mavenCentral(). Когда Gradle видит зависимость testImplementation 'org.junit.jupiter:junit-jupiter:5.9.3', он загружает её из этого репозитория.

**Источник:**
- **Git** https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository
- **Maven/Gradle:** https://docs.gradle.org/current/userguide/declaring_repositories.html

---

#### Инструмент сборки — Build Tool

**Определение:** Инструмент сборки — это программное обеспечение, которое автоматизирует процессы преобразования исходного кода в готовое к запуску приложение. Он управляет такими задачами, как компиляция, управление зависимостями, запуск тестов, статический анализ и упаковка артефактов (JAR, WAR). Gradle, Maven и Ant являются примерами таких инструментов в экосистеме Java.
**Контекст использования:** Инструменты сборки устраняют необходимость в ручных скриптах, обеспечивая единый, воспроизводимый и автоматизированный процесс для всех разработчиков. Они управляют сложными цепочками задач (task pipeline), разрешают зависимости между библиотеками и легко интегрируются в системы CI/CD, что является стандартом в современной разработке.

**Пример:** **Пример:** В проекте devtools в качестве инструмента сборки используется Gradle. Он выполняет задачи, описанные в build.gradle: компиляцию Java-кода (compileJava), запуск тестов (test) и создание JAR-артефакта (jar).

**Источник:** https://docs.gradle.org/current/userguide/userguide.html

---

#### IDE / IntelliJ IDEA — Integrated Development Environment / IntelliJ IDEA

**Определение:**
- IDE (Интегрированная среда разработки) — это комплексное программное обеспечение, объединяющее редактор исходного кода, инструменты сборки, отладки, тестирования, контроль версий и другие средства в единый интерфейс для повышения производительности разработчика

- IntelliJ IDEA — это интегрированная среда разработки, созданная компанией JetBrains, которая изначально была ориентирована на Java, а теперь поддерживает множество других языков, таких как Kotlin, Python, JavaScript и другие

**Контекст использования:** IDE используется для повседневной разработки программного обеспечения, чтобы программист мог сконцентрироваться на логике и функциональности, в то время как среда берёт на себя рутинные операции вроде автодополнения кода, рефакторинга, навигации и сборки проекта. IntelliJ IDEA, будучи одной из самых популярных IDE для экосистемы Java, предоставляет развитые инструменты для работы с Java, Gradle, системой контроля версий Git и другими технологиями, используемыми в курсе.

**Пример:** В рамках модуля Dev Tools вы используете IntelliJ IDEA Community Edition для работы над проектом devtools: создаёте Java-классы, редактируете файл build.gradle, запускаете задачи Gradle (например, ./gradlew check), работаете с Git-репозиторием и отлаживаете код с помощью встроенного дебаггера.

**Источник:**
- **Об IDE:** https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html 

- **О IntelliJ IDEA:** https://www.jetbrains.com/ru-ru/idea/

---

### Категория: Процессы и практики

#### Code Review — Code Review

**Определение:** Практика совместного анализа исходного кода, предложенного для слияния в основную ветку, другими членами команды. Цель — улучшить качество кода, найти ошибки, удостовериться в соответствии стандартам проекта и распространить знания о кодовой базе.

**Контекст использования:** Code review является критически важной практикой в современной разработке, особенно при работе с системами контроля версий, такими как Git, на платформах вроде GitHub или GitLab. Он служит последним рубежом контроля качества перед интеграцией изменений в стабильную ветку (например, master), помогает поддерживать единый стиль в команде и является ключевым инструментом обучения и обмена опытом.

**Пример:** В рамках курса после выполнения задания (например, DVT-12) студент создаёт Pull Request (PR) на GitHub. Наставник или другие студенты проводят code review этого PR: проверяют логику, читаемость кода, соответствие заданию и требованиям Checkstyle. Автор PR дорабатывает код по комментариям, после чего изменения одобряются и сливаются (merge) в ветку master.

**Источник:** https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/about-pull-request-reviews

---

## Вопросы по сложным терминам

### Вопрос 1: Различие между JDK, JRE и JVM

**Задача:** Чётко понять разницу между JDK, JRE и JVM и сферу применения каждого компонента в процессе разработки и запуска Java-приложений.

**Контекст:** Изучил официальные определения в Oracle Docs, добавил их в глоссарий, но на практике не до конца понятно, когда используется каждый из компонентов. В IntelliJ IDEA настраивается JDK, а для запуска приложения, возможно, нужна только JRE.

**Ограничения:** В статьях в интернете информация часто противоречивая или устаревшая. Простого сравнения на уровне "JDK для разработки, JRE для запуска" недостаточно, чтобы понять, как они связаны технически.

**Ожидаемый результат:** Умение объяснить, чем отличается функциональность JDK, JRE и JVM, и указать, какой компонент используется на каждом этапе (написание, компиляция, запуск, выполнение). Понимание, можно ли установить только JRE для запуска приложения, если JDK уже установлен.

**Критерии успеха:** Смогу нарисовать схему или составить таблицу, объясняющую вложение компонентов (JDK включает JRE, JRE включает JVM) и их ответственность. Смогу дать чёткий ответ коллеге на вопрос: "Мне нужно просто запустить готовый JAR-файл. Что должно быть установлено на сервере — JDK или JRE?"

---

### Вопрос 2: Различие между Git-репозиторием и Maven-репозиторием

**Задача:** Разграничить понятия "репозиторий" в контексте системы контроля версий (Git) и в контексте систем сборки/менеджеров зависимостей (Maven, Gradle), чтобы избежать путаницы в документации и общении.

**Контекст:** В глоссарии создана общая запись "Repository", где описаны оба значения. На практике в проекте devtools есть удалённый Git-репозиторий на GitHub, и в build.gradle объявлен репозиторий mavenCentral() для загрузки библиотек. Термин один, а сущности разные.

**Ограничения:** В разговорной речи часто говорят просто "репозиторий", и из контекста не всегда сразу понятно, о чём идёт речь (об исходном коде или о библиотеках).

**Ожидаемый результат:** Чёткое понимание, что Git-репозиторий — это хранилище истории исходного кода проекта, а Maven-репозиторий — это каталог (артефактов) с готовыми библиотеками. Умение правильно использовать и пояснять термин в зависимости от контекста.

**Критерии успеха:** При чтении фразы вроде "зависимость загружается из репозитория" смогу однозначно определить, что речь о Maven-репозитории. Смогу объяснить новичку, что git clone и mavenCentral() — это операции с разными типами репозиториев, даже если в предложении используется одно и то же слово.



